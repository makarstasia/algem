Программа нахождения частного и остатка от деления полинома по формуле: P(z) = Q(z)q(z) + r(z)
Макаршина Анастасия Алексеевна
КФУ, Прикладная математика, 1 курс, группа  09-021
----------------------------------------------------------------------------------------------------------
Аннотация
Программа реализована на языке программирования Python. Метод для деления многочлена с остатком написан для использования без подключения дополнительной библиотеки NumPy, “вручную”. Суть метода заключается в создании функции, которая при получении коэффициентов полинома обрабатывает их, добавляя в массив, а специальный метод def polydiv(), получая массивы коэффициентов, создает два новых массива с коэффициентами целой части и остатка.

Технические подробности:
Входные массивы - это коэффициенты (включая любые коэффициенты ( с учетом 0)
«числителя» (делимого) и «знаменателя» (делителя) полинома соответственно.
Параметры
    ----------
    u: array_like или poly1d
        Коэффициенты делимого полинома.
    v: array_like или poly1d
        Коэффициенты полинома делителя.

Возврат
    -------
    q: ndarray
        Коэффициенты частного, в том числе равные нулю.
    г: ndarray
        Коэффициенты остатка, в том числе равные нулю.
Заметки
    -----
    И `u`, и` v` должны быть 0-d или 1-d (ndim = 0 или 1), но  `u.ndim` должно быть
    не равно `v.ndim`. Другими словами, все четыре возможных комбинации -
    `` u.ndim = v.ndim = 0 '', `` u.ndim = v.ndim = 1 '',
    `` u.ndim = 1, v.ndim = 0 '' и `` u.ndim = 0, v.ndim = 1 '' - работают.

----------------------------------------------------------------------------------------------------------
Листинг программы.

import re
import numpy.core.numeric as NX
from numpy.core import (atleast_1d, array)
class poly1d:
   __hash__ = None

def polydiv(u, v):

   truepoly = (isinstance(u, poly1d) or isinstance(u, poly1d))
   u = atleast_1d(u) + 0.0
   v = atleast_1d(v) + 0.0
   # w has the common type
   w = u[0] + v[0]
   m = len(u) - 1
   n = len(v) - 1
   scale = 1. / v[0]
   q = NX.zeros((max(m - n + 1, 1),), w.dtype)
   r = u.astype(w.dtype)
   for k in range(0, m-n+1):
       d = scale * r[k]
       q[k] = d
       r[k:k+n+1] -= d*v
   while NX.allclose(r[0], 0, rtol=1e-14) and (r.shape[-1] > 1):
       r = r[1:]
   if truepoly:
       return poly1d(q), poly1d(r)
   return q, r

_poly_mat = re.compile(r"[*][*]([0-9]*)")

#example
x = array([3.0, 5.0, 2.0])
y = array([2.0, 1.0])
print(polydiv(x, y))

----------------------------------------------------------------------------------------------------------
Пример с пояснением 
P(z) = Q(z)q(z) + r(z)
1)запишем в массив х коэффициенты уравнения P(z) = 3x^2 + 5x +2
2)запишем  в массив y коэффициенты уравнения Q(z) = 2x+1

отрывок кода с примером:
x = array([3.0, 5.0, 2.0])
y = array([2.0, 1.0])
print(polydiv(x, y))

Пример вывода из среды разработки PyCharm.
на выходе мы получили два массива:
в первом коэффициенты целой части q(z) :  (array([1.5 , 1.75])
во-втором коэффициенты остатка от деления r(z) : array([0.25]))
----------------------------------------------------------------------------------------------------------
Результаты
В ходе программы при делении двух многочлнов удалось получить коэффициенты
целой части и остатка. 
Метод был успешно реализован.


